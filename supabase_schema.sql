-- ==========================================
-- ESQUEMA COMPLETO DE SUPABASE
-- Incluye tablas, RLS, políticas, funciones, vistas y triggers
-- ==========================================

-- ==========================================
-- SECCIÓN A: MENSAJES (Formulario público)
-- ==========================================
drop table if exists public.messages cascade;
create table public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  email text not null,
  message text not null
);

alter table public.messages enable row level security;
drop policy if exists "Cualquiera puede enviar mensajes" on public.messages;
create policy "Cualquiera puede enviar mensajes"
on public.messages for insert
with check (true);

-- ==========================================
-- SECCIÓN E: PROTECCIÓN ANTI-SPAM Y RATE LIMIT
-- Aplicado sobre la tabla public.messages
-- ==========================================

-- 1) Columna honeypot (hp) para detectar bots rellenando campos ocultos
alter table public.messages
add column if not exists hp text not null default '';

-- 2) Índice para acelerar consultas por email/fecha usadas en rate limit
create index if not exists messages_email_created_at_idx
on public.messages (email, created_at);

-- 3) Función y trigger: restricciones de envío
--   - mínimo 60s entre envíos por email
--   - máximo 5 envíos por día por email
--   - cortar si el honeypot viene relleno
create or replace function public.enforce_contact_rate()
returns trigger
language plpgsql
security definer
as $$
begin
  -- Espera mínima entre envíos
  if exists (
    select 1
    from public.messages m
    where m.email = new.email
      and m.created_at > now() - interval '60 seconds'
  ) then
    raise exception 'Por favor espera 60s antes de enviar de nuevo.' using errcode = '22023';
  end if;

  -- Máximo por día
  if (
    select count(*)
    from public.messages m
    where m.email = new.email
      and m.created_at > now() - interval '1 day'
  ) >= 5 then
    raise exception 'Has alcanzado el límite diario de envíos.' using errcode = '22023';
  end if;

  -- Honeypot activado
  if coalesce(trim(new.hp), '') <> '' then
    raise exception 'Protección anti-spam activada.' using errcode = '22023';
  end if;

  return new;
end;
$$;

drop trigger if exists contact_rate_limit on public.messages;
create trigger contact_rate_limit
before insert on public.messages
for each row
execute procedure public.enforce_contact_rate();

-- ==========================================
-- SECCIÓN B: PERFILES (auth.users + perfil extendido)
-- ==========================================
drop table if exists public.profiles cascade;
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  role text default 'user',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles enable row level security;
drop policy if exists "Usuarios pueden ver su propio perfil" on public.profiles;
create policy "Usuarios pueden ver su propio perfil"
on public.profiles for select
using ( auth.uid() = id );

drop policy if exists "Usuarios pueden actualizar su propio perfil" on public.profiles;
create policy "Usuarios pueden actualizar su propio perfil"
on public.profiles for update
using ( auth.uid() = id );

drop policy if exists "Usuarios pueden crear su perfil" on public.profiles;
create policy "Usuarios pueden crear su perfil"
on public.profiles for insert
with check ( auth.uid() = id );

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'user');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- ==========================================
-- SECCIÓN C: ROLES PERSONALIZADOS + PERMISOS
-- ==========================================
drop table if exists public.app_roles cascade;
create table public.app_roles (
  role_name text primary key,
  label text,
  permissions text[]
);

insert into public.app_roles (role_name, label, permissions) values
('admin', 'Administrador', array['access_admin_panel', 'view_messages', 'reply_messages', 'delete_messages', 'manage_users', 'view_analytics']),
('support', 'Soporte', array['access_admin_panel', 'view_messages', 'reply_messages']),
('editor', 'Editor', array['access_admin_panel', 'view_analytics']),
('user', 'Usuario', array[]::text[])
on conflict (role_name) do update set
  label = excluded.label,
  permissions = excluded.permissions;

alter table public.profiles 
drop constraint if exists fk_profiles_role;
alter table public.profiles
add constraint fk_profiles_role
foreign key (role) 
references public.app_roles (role_name)
on update cascade;

alter table public.app_roles enable row level security;
drop policy if exists "Todos pueden leer roles" on public.app_roles;
create policy "Todos pueden leer roles"
on public.app_roles for select
using (true);

create or replace view public.users_with_permissions as
select 
  p.id,
  p.email,
  p.role,
  r.permissions
from public.profiles p
left join public.app_roles r on p.role = r.role_name;

-- ==========================================
-- SECCIÓN D: POLÍTICAS ADMIN SEGURAS (sin recursión)
-- ==========================================
drop function if exists public.is_admin();
create or replace function public.is_admin()
returns boolean as $$
begin
  return exists (
    select 1 from public.profiles
    where id = auth.uid() and role = 'admin'
  );
end;
$$ language plpgsql security definer;

drop policy if exists "Admins pueden ver todos los perfiles" on public.profiles;
create policy "Admins pueden ver todos los perfiles"
on public.profiles for select
using (
  auth.uid() = id
  OR
  public.is_admin()
);

drop policy if exists "Admins pueden actualizar cualquier perfil" on public.profiles;
create policy "Admins pueden actualizar cualquier perfil"
on public.profiles for update
using (
  auth.uid() = id
  OR
  public.is_admin()
);
