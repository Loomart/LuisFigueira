-- ==========================================
-- ESQUEMA COMPLETO DE SUPABASE
-- Incluye tablas, RLS, políticas, funciones, vistas y triggers
-- ==========================================

-- ==========================================
-- SECCIÓN A: MENSAJES (Formulario público)
-- ==========================================
drop table if exists public.messages cascade;
create table public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  email text not null,
  message text not null
);

alter table public.messages enable row level security;
drop policy if exists "Cualquiera puede enviar mensajes" on public.messages;
create policy "Cualquiera puede enviar mensajes"
on public.messages for insert
with check (true);

-- ==========================================
-- SECCIÓN B: PERFILES (auth.users + perfil extendido)
-- ==========================================
drop table if exists public.profiles cascade;
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  role text default 'user',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles enable row level security;
drop policy if exists "Usuarios pueden ver su propio perfil" on public.profiles;
create policy "Usuarios pueden ver su propio perfil"
on public.profiles for select
using ( auth.uid() = id );

drop policy if exists "Usuarios pueden actualizar su propio perfil" on public.profiles;
create policy "Usuarios pueden actualizar su propio perfil"
on public.profiles for update
using ( auth.uid() = id );

drop policy if exists "Usuarios pueden crear su perfil" on public.profiles;
create policy "Usuarios pueden crear su perfil"
on public.profiles for insert
with check ( auth.uid() = id );

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'user');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- ==========================================
-- SECCIÓN C: ROLES PERSONALIZADOS + PERMISOS
-- ==========================================
drop table if exists public.app_roles cascade;
create table public.app_roles (
  role_name text primary key,
  label text,
  permissions text[]
);

insert into public.app_roles (role_name, label, permissions) values
('admin', 'Administrador', array['access_admin_panel', 'view_messages', 'reply_messages', 'delete_messages', 'manage_users', 'view_analytics']),
('support', 'Soporte', array['access_admin_panel', 'view_messages', 'reply_messages']),
('editor', 'Editor', array['access_admin_panel', 'view_analytics']),
('user', 'Usuario', array[]::text[])
on conflict (role_name) do update set
  label = excluded.label,
  permissions = excluded.permissions;

alter table public.profiles 
drop constraint if exists fk_profiles_role;
alter table public.profiles
add constraint fk_profiles_role
foreign key (role) 
references public.app_roles (role_name)
on update cascade;

alter table public.app_roles enable row level security;
drop policy if exists "Todos pueden leer roles" on public.app_roles;
create policy "Todos pueden leer roles"
on public.app_roles for select
using (true);

create or replace view public.users_with_permissions as
select 
  p.id,
  p.email,
  p.role,
  r.permissions
from public.profiles p
left join public.app_roles r on p.role = r.role_name;

-- ==========================================
-- SECCIÓN D: POLÍTICAS ADMIN SEGURAS (sin recursión)
-- ==========================================
drop function if exists public.is_admin();
create or replace function public.is_admin()
returns boolean as $$
begin
  return exists (
    select 1 from public.profiles
    where id = auth.uid() and role = 'admin'
  );
end;
$$ language plpgsql security definer;

drop policy if exists "Admins pueden ver todos los perfiles" on public.profiles;
create policy "Admins pueden ver todos los perfiles"
on public.profiles for select
using (
  auth.uid() = id
  OR
  public.is_admin()
);

drop policy if exists "Admins pueden actualizar cualquier perfil" on public.profiles;
create policy "Admins pueden actualizar cualquier perfil"
on public.profiles for update
using (
  auth.uid() = id
  OR
  public.is_admin()
);
